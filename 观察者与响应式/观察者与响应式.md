`Vue`其实说简单的话主要是两部分组成,数据响应式,虚拟DOM,当数据发生变动时调动`render`函数,重新渲染`UI`,而响应式总的则是采用的观察者模式(又称发布-订阅模式)来保证当数据发生变动时通知所以依赖他的对象进行更新

###  跑个题

我们现在构想一下以下情景,

​	当我们去卖水果,那肯定有好多家水果店,那如果我们跑了好几家都有各种优惠措施,我们肯定不可能每次都跑过去问最近有没有优惠措施,那我们就可以把电话留给店里面,每当他们有什么优惠微信通知我们,然后我们再决定.这就是发布订阅模式,我们订阅店里面的信息,每当店里面有什么优惠信息,根据我们留下的电话去通知我们,这就是一个观察者模式,

### 事件与触发

​	在`Javascript`中有一个很重要的思路是事件,当事件发生调用回调,是不是很类似我们上面说的情景,那么我们自己尝试着来实现以下`EventEmitter`

```js
 let EventEmitter = (function(){
  class _EventEmitter{
    constructor() {
      this._events = Object.create(null);
    }

    get events() {
      return this._events;
    }

    set events(value) {
      throw `can not set events,please call addListener or removeListener to set events`
    }

    on(type, callback) {
      if(!this._events[type]){
        this._events[type] = [];
      }
      if(typeof callback !== 'function')return;

      this._events[type].push(callback)
    }

    addListener(type, callback){
      this.on(type, callback)
    }

    removeListener(type, callback){
      if(!this._events[type])return;
      let callbacks = this._events[type];
      let idx = callbacks.findIndex(item === callback);
      if(idx > -1){
        callback.splice(idx,1)
      }
    }

    emit(type,...args){
      if(!this._events[type]) { return; }

      let callbacks = this._events[type]
      callbacks.forEach(callback => {
        Reflect.apply(callback,this,args)
      })
    }
  }

    let instance;
    let EventEmitter = new Proxy(_EventEmitter,{
      construct(target,args){
        if(instance){
          return instance
        }
        return instance = Reflect.construct(target,args)
      }
    })

    return EventEmitter
 })()
```

这样,我们就实现了一个建议的事件系统,每当某个事件被触发,系统会根绝我们注册的函数一个个的调用,是不是很类似上面例子所说的情况,事实上,`Vue`的早期版本就是采用了事件机制来进行`UI`的更新,但是新版本的`Vue`则使用了另外一种方式来实现,

### 卖个关子

现在我们来看一下`Vue`中的一个`API`,

> ### vm.$watch( expOrFn, callback, [options\] )]  
>
> **用法**：
>
> 观察 Vue 实例变化的一个表达式或计算属性函数。回调函数得到的参数为新值和旧值。表达式只接受监督的键路径。对于更复杂的表达式，用一个函数取代。
>
> `vm.$watch` 返回一个取消观察函数，用来停止触发回调：

我们看一下最后一句话,`vm.$watch` 返回一个取消观察函数，用来停止触发回调,如果要实现这个功能,那么上面的`EventEmitter`类就无法达成了;