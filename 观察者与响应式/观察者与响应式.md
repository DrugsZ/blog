`Vue`其实说简单的话主要是两部分组成,数据响应式,虚拟DOM,当数据发生变动时调动`render`函数,重新渲染`UI`,而响应式总的则是采用的观察者模式(又称发布-订阅模式)来保证当数据发生变动时通知所以依赖他的对象进行更新

###  跑个题

我们现在构想一下以下情景,

​	当我们去卖水果,那肯定有好多家水果店,那如果我们跑了好几家都有各种优惠措施,我们肯定不可能每次都跑过去问最近有没有优惠措施,那我们就可以把电话留给店里面,每当他们有什么优惠微信通知我们,然后我们再决定.这就是发布订阅模式,我们订阅店里面的信息,每当店里面有什么优惠信息,根据我们留下的电话去通知我们,这就是一个观察者模式,

### 事件与触发

​	在`Javascript`中有一个很重要的思路是事件,当事件发生调用回调,是不是很类似我们上面说的情景,那么我们自己尝试着来实现以下`EventEmitter`

```js
 let EventEmitter = (function(){
  class _EventEmitter{
    constructor() {
      this._events = Object.create(null);
    }

    get events() {
      return this._events;
    }

    set events(value) {
      throw `can not set events,please call addListener or removeListener to set events`
    }

    on(type, callback) {
      if(!this._events[type]){
        this._events[type] = [];
      }
      if(typeof callback !== 'function')return;

      this._events[type].push(callback)
    }

    addListener(type, callback){
      this.on(type, callback)
    }

    removeListener(type, callback){
      if(!this._events[type])return;
      let callbacks = this._events[type];
      let idx = callbacks.findIndex(item === callback);
      if(idx > -1){
        callback.splice(idx,1)
      }
    }

    emit(type,...args){
      if(!this._events[type]) { return; }

      let callbacks = this._events[type]
      callbacks.forEach(callback => {
        Reflect.apply(callback,this,args)
      })
    }
  }

    let instance;
    let EventEmitter = new Proxy(_EventEmitter,{
      construct(target,args){
        if(instance){
          return instance
        }
        return instance = Reflect.construct(target,args)
      }
    })

    return EventEmitter
 })()
```

这样,我们就实现了一个建议的事件系统,每当某个事件被触发,系统会根绝我们注册的函数一个个的调用,是不是很类似上面例子所说的情况,事实上,`Vue`的早期版本就是采用了事件机制来进行`UI`的更新,但是新版本的`Vue`则使用了另外一种方式来实现,



### 初级版本

现在我们想象怎么去实现,

```js
//首先我们定义一个筐存放所有的回调函数,同时在我们观测的的数据发生变化是调用订阅者

let deps = [];

a={
    b:1
};

const property = Object.getOwnPropertyDescriptor(a, 'b');
const getter = property && property.get;
const setter = property && property.set;
Object.defineProperty(a,'b',{
    enumerable:true,
    configurable:true,
    
    get:getter,
    set: function reactiveSetter(newVal) {
        const value = getter

        if (Object.is(value, newVal)) {
            return;
        }

        if (setter) {
            setter.call(obj, newVal);
        }

        deps.forEach(function(dep){
           dep.apply(this) 
        },a)
    },
})

deps.push(()=>{
  console.log('目标被改动了')
})
```

这样我们就完成了一个很初级的版本,每当`a.b`被改动,`deps`内的函数就会被依次调动,但是这个版本有很多的问题

- 依赖的收集并不是自动的
- `deps`的创建也不是自动的

那么我们来思考一下如何去解决,首先,我们可以对每个属性在被观察时进行创建`deps`同时在重设`setter`时来做这一步,这样首先所有的`deps`是可以跟我们观察的对象一一对应的,同时在`setter`时进行可以将其创建成私有变量,避免其被修改,

那么依赖的收集如何自动进行呢?首先我们想想,为什么要收集依赖,是因为这个值被使用了,所以我们才要收集这个值的依赖,那么



### 改进版本一

```js
export default class Dep {
  constructor() {
    this.subs = new Map();
  }

  addSub(sub) {
    if (!this.subs.has(sub.id)) {
      this.subs.set(sub.id, sub);
    }
  }

  depend() {
    Dep.target.addDep(this);
  }

  removeSub(sub) {
    let result;
    if (this.subs.has(sub.id)) {
      result = this.subs.get(sub.id);
      this.subs.delete(sub.id);
    }
    return result;
  }

  notify() {
    this.subs.forEach(sub => sub());
  }
}

const defineReactive = (obj, key, val = obj[key]) => {
  const dep = new Dep();

  const property = Object.getOwnPropertyDescriptor(obj, key);
  if (property && property.configurable === false) return;

  const getter = property && property.get;
  const setter = property && property.set;


  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,

    get: getter
    set: function reactiveSetter(newVal) {
      const value = getter ? getter.call(obj) : val;

      if (Object.is(value, newVal)) {
        return;
      }

      if (setter) {
        setter.call(obj, newVal);
      } else {
        val = newVal;
      }

      dep.notify();
    },
  });
};


const walk = (obj) => {
  const keys = Object.keys(obj);
  for (let i = 0; i < keys.length; i++) {
    defineReactive(obj, keys[i]);
  }
};

export default class Observe {
  constructor(value) {
    this.value = value;
    walk(value);
  }
}
```



### 卖个关子

现在我们来看一下`Vue`中的一个`API`,

> ### vm.$watch( expOrFn, callback, [options\] )]  
>
> **用法**：
>
> 观察 Vue 实例变化的一个表达式或计算属性函数。回调函数得到的参数为新值和旧值。表达式只接受监督的键路径。对于更复杂的表达式，用一个函数取代。
>
> `vm.$watch` 返回一个取消观察函数，用来停止触发回调：

我们看一下最后一句话,`vm.$watch` 返回一个取消观察函数，用来停止触发回调,如果要实现这个功能,那么上面的`EventEmitter`类就无法达成了;